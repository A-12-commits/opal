require 'opal/nodes/base'

module Opal
  module Nodes
    class CallNode < Base
      handle :call

      children :recvr, :meth, :arglist, :iter

      def compile
        if handled = self.handle_special
          push handled
          return
        end

        mid = mid_to_jsid meth.to_s

        compiler.method_calls << meth.to_sym

        # trying to access an lvar in irb mode
        if using_irb?
          with_temp do |tmp|
            lvar = variable(meth)
            call = s(:call, s(:self), meth.intern, s(:arglist))
            push "((#{tmp} = $opal.irb_vars.#{lvar}) == null ? ", expr(call), " : #{tmp})"
          end

          return
        end

        splat = arglist[1..-1].any? { |a| a.first == :splat }

        if Sexp === arglist.last and arglist.last.type == :block_pass
          block = expr(arglist.pop)
        elsif iter
          block = expr(iter)
        end

        tmpfunc = scope.new_temp if block
        tmprecv = scope.new_temp if splat || tmpfunc

        recv_code = recv(recv_sexp)
        call_recv = s(:js_tmp, tmprecv || recv_code)

        if tmpfunc and !splat
          arglist.insert 1, call_recv
        end

        args = expr(arglist)

        if tmprecv
          push "(#{tmprecv} = ", recv_code, ")#{mid}"
        else
          push recv_code, mid
        end

        if tmpfunc
          unshift "(#{tmpfunc} = "
          push ", #{tmpfunc}._p = ", block, ", #{tmpfunc})"
        end

        if splat
          push ".apply("
          push(tmprecv || recv_code)
          push ", ", args, ")"
        elsif tmpfunc
          push ".call(", args, ")"
        else
          push "(", args, ")"
        end

        scope.queue_temp tmpfunc if tmpfunc
      end

      def recv_sexp
        recvr || s(:self)
      end

      def using_irb?
        @compiler.irb? and scope.top? and arglist == s(:arglist) and recvr.nil? and iter.nil?
      end

      # Handle "special" method calls, e.g. require(). Subclasses can override
      # this method. If this method returns nil, then the method will continue
      # to be generated by CallNode.
      def handle_special
        case meth
        when :require then handle_require
        when :autoload then handle_autoload
        when :block_given? then handle_block_given
        when :__method__, :__callee__ then handle_callee
        end
      end

      def handle_require
        str = DependencyResolver.new(compiler, arglist[1]).resolve
        compiler.requires << str unless str.nil?
        fragment ''
      end

      def handle_autoload
        if scope.class_scope?
          str = DependencyResolver.new(compiler, arglist[2]).resolve
          compiler.requires << str unless str.nil?
          fragment ''
        end
      end

      def handle_block_given
        compiler.handle_block_given_call @sexp
      end

      def handle_callee
        if scope.def?
          fragment scope.mid.to_s.inspect
        else
          fragment 'nil'
        end
      end

      class DependencyResolver
        def initialize(compiler, sexp)
          @compiler = compiler
          @sexp = sexp
        end

        def resolve
          handle_part @sexp
        end

        def handle_part(sexp)
          type = sexp.type

          if type == :str
            return sexp[1]
          elsif type == :call
            _, recv, meth, args = sexp

            parts = args[1..-1].map { |s| handle_part s }

            if recv == [:const, :File]
              if meth == :expand_path
                return expand_path(*parts)
              elsif meth == :join
                return expand_path parts.join('/')
              elsif meth == :dirname
                return expand_path parts[0].split('/')[0...-1].join('/')
              end
            end
          end

          msg = "Cannot handle dynamic require"
          case @compiler.dynamic_require_severity
          when :error
            @compiler.error msg
          when :warning
            @compiler.warning msg
          end
        end

        def expand_path(path, base = '')
          "#{base}/#{path}".split("/").inject([]) do |p, part|
            if part == ''
              # we had '//', so ignore
            elsif part == '..'
              p.pop
            else
              p << part
            end

            p
          end.join "/"
        end
      end
    end
  end
end
